/* Эту задачу нельзя решить работой только со сроками, поскольку строки не имеют методов для определения отдельных слов
   в них и в цикле мы можем обходить только каждую отдельную букву, задачу упрощает работа с массивами
   мы можем разделить строку на массив из слов составляющих строку, и проверять если слово уже есть в строке, чтобы не 
   добавлять его заново, найти слово для удаления или замены, и в конечном счете преобразовать массив обратно в строку 
   и перезаписать значение в объекте хранящее строку
*/

const obj = {  //объявляем переменную obj и записываем в нее объект со совйством words в которое записываем строку с словами
    words: 'newspapers newspapers books magazines'
};

function addWords(myObj, wrds) { //объвляем функцию addWords с двумя аргументами myObj и wrds, в wrds будут переданы слова для добавления
    let words = myObj.words; //объявляем переменную words и записываем в нее значене свойства words объекта переданного в функцию при вызове и записанного в myObj
    let arr = words.split(' '); //объявляем переменную arr и записываем в нее массив созданный из строки words в качестве разделителя передаем пробел
    let arr2 = wrds.split(' '); //бъявляем переменную arr2 и записываем в нее массив созданный из строки wrds переданной в качестве аргумента функции при вызове
    for (let i = 0; i < arr2.length; i++) { //объявляем цикл который начнется с 0 до значения длинны массива в переменной arr2

        let word = arr2[i]; //объявим внутри цикла переменную word и запишем в нее значение по индексу текущего счетчика i из массива arr2
        let index = arr.indexOf(word); //объявим переменную index и запишем в нее индекс значения переменной word в массиве arr, если слова в переменной word нет в массиве, метод indexOf вернет -1

        if (index === -1 && word !== '') { //проверим язляется ли индекс равным -1 (слова нет в массиве) и не равно ли слово пустой строке
            arr.push(word);  //елси слова нет в массиве, добавим его
        }

    }
    arr = arr.filter(function(value, index) { //отфильтруем дубликаты из массива arr с помощью метода filter и перезапишем значение arr на отфильтрованное
        return arr.indexOf(value) === index; //метод filter вызывает функцию коллбек, которая принимает 2 аргумента value и index и возвращает true или false, что говорит записывать или нет текущий элемент в масси, filter работает как цикл и обходит весь массив проверя соответсвует ли значение индексу, если функция коллбек найдет слово по несоответсвующему циклу она его пропустит, так как это дубликат
    });
    words = arr.join(' '); //присвоим переменной words новое значение строки с добавленным в массив словами, преобразованными в строку с помощью метода join и переданного в качестве разделителя пробела
    myObj.words = words; //запишем в обьект переданный в качетсве аргумента myObj в функцию при вызове новое значение свойства words равное значению в нашей переменной words
}

function removeWords(myObj, wrds) { //объявляем функцию removeWords с двумя аргументами myObj и wrds, в wrds будут храниться слова для удаления
    let words = myObj.words; //объявляем переменную words где будем хранить копию строки из свойства words объекта myObj переданного в функцию в качестве агрумента
    let arr = words.split(' '); //объявляем переменную arr и записываем в нее массив созданный из строки words в качестве разделителя передаем пробел
    let arr2 = wrds.split(' '); //бъявляем переменную arr2 и записываем в нее массив созданный из строки wrds переданной в качестве аргумента функции при вызове
    for (let i = 0; i < arr2.length; i++) { //объявляем цикл который начнется с 0 до значения длинны массива в переменной arr2

        let word = arr2[i]; //объявим внутри цикла переменную word и запишем в нее значение по индексу текущего счетчика i из массива arr2
        let index = arr.indexOf(word); //объявим переменную index и запишем в нее индекс значения переменной word в массиве arr, если слова в переменной word нет в массиве, метод indexOf вернет -1

        if (index !== -1) { //Если в переменной index значение не равно -1 (значит что слово есть в массиве и соответственно в исходной строке) попадаем в код в фигурных скобках
            arr.splice(index, 1); //вызываем метод slpice на массиве со словами arr, метод splice является универсальным, может добавлять, удалять и заменять элементы массива, для этого первым аргументом в splice передается индекс элемента в массиве, вторым - количество элементов которые нужно удалить, в нашем случае это 1, так как мы удаляем по 1 слову в цикле перебирая массив из слов которые надо удалить
        }

    }
    words = arr.join(' '); //перезаписываем значение в переменной words из 34 строки значением массива с удаленными словами преобразованному к строке методом join
    myObj.words = words; //запишем в обьект переданный в качетсве аргумента myObj в функцию при вызове новое значение свойства words равное значению в нашей переменной words
}

function changeWords(myObj, oldWrds, newWrds) { //объявим функцию changeWords с тремя аргументами myObj, oldWrds и newWrds, в oldWrds будут переданы слова которые нужно заменить, в newWrds - слова которыми нужно заменить слова из oldWrds
    let words = myObj.words; //весь код дальше анологичен коду из функци выше кроме того что мы определяем 3 массива, из исходной строки которую надо изменить, строки слов которые надо заменить и строки слов на которые нужно заменить
    let arr = words.split(' '); //массив из исходной строки в переменной words
    let arr2 = oldWrds.split(' '); //массив из слов которые нужно заменить
    let arr3 = newWrds.split(' '); //массив из слов на которые нужно заменить
    for (let i = 0; i < arr2.length; i++) { //цикл аналогичен...

        let word = arr2[i];
        let index = arr.indexOf(word);

        if (index !== -1) {
            arr.splice(index, 1, arr3.shift());  //...кроме этого момента, теперь мы передаем в метод splice третий аргумент, который является значением на которое мы будем заменять нужное слово, мы передаем не просто значение в массиве, а значение массива вырезанное из начала методом shift - этот медот вырезает из массива значение по нулевому индексу и возвращает его нам, мы это делаем для того, чтобы добавлять слова по порядку и не отмечать их как добавленные, удаляя их из начала массива, на следующей итерации цикла мы будем иметь нужное слово для вставки по нулевому индексу
        }

    }
    words = arr.join(' '); //тут аналогично 47й строке предыдущей функции
    myObj.words = words; //тут аналогично 48й строке предыдущей функции
}
